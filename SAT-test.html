<!DOCTYPE html>
<html>
<!--
  Created using jsbin.com
  Source can be edited via http://jsbin.com/jerid/2/edit
-->
<head>
<meta name="description" content="point in a polygon test 3" />
  <meta charset="utf-8">
  <title>SAT Test</title>

<style id="jsbin-css">
canvas {
  background-color:lightblue;
  margin:0;
}
/* body {margin: 0; padding: 0;} */
</style>
</head>
<body>
  <canvas id="myCanvas"></canvas>
  <p id="result"></p>
<script>
var canv=document.getElementById("myCanvas");
canv.width=400;
canv.height=300;
var ctx=canv.getContext("2d");

var polygons = [
  [
    [50,10],
    [60,30],
    [80,20],
    [70,40],
    [80,60],
    [50,50],
    [20,60],
    [40,40],
    [10,20],
    [40,30]
  ],[
    [150,70],
    [170,80],
    [170,110],
    [140,120],
    [130,100],
    [130,80]
  ],[
    [130,160],
    [170,150],
    [180,190],
    [170,230],
    [130,200]
  ],[
    [260,140],
    [260,170],
    [220,180],
    [210,170],
    [200,140]
  ],[
    [300,90],
    [320,140],
    [300,160],
    [290,150],
    [280,110]
  ]
];

polygons[0].name="star";
polygons[1].name="top left";
polygons[2].name="bottom left";
polygons[3].name="middle";
polygons[4].name="right";

// thanks to http://stackoverflow.com/a/17490457 for this function
function insidePoly(pointx, pointy) {
  var inside = false;
  polygons.forEach(function(polygon){
    var i,j;
    for (i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
      if( ((polygon[i][1] > pointy) != (polygon[j][1] > pointy)) && (pointx < (polygon[j][0]-polygon[i][0]) * (pointy-polygon[i][1]) / (polygon[j][1]-polygon[i][1]) + polygon[i][0]) ) inside = !inside;
    }
  })
  return inside;
}

// but then I had to add in this function, as you can't exit a foreach.
// It's a complicated way as I couldn't get this one to stop detecting hits
// when the click was to the right (and outside) of a given polygon, so it's
// only called after insidePoly.
function insideWhichPoly(pointx, pointy) {
  for (var k=0; k<polygons.length; k++){  
    var i,j;
    for (i = 0, j = polygons[k].length - 1; i < polygons[k].length; j = i++) {
      if ( 
          ((polygons[k][i][1] > pointy) != (polygons[k][j][1] > pointy)) && 
          (pointx < (polygons[k][j][0]-polygons[k][i][0]) * (pointy-polygons[k][i][1]) / (polygons[k][j][1]-polygons[k][i][1]) + polygons[k][i][0]) 
          ) {
        drawSinglePoly(polygons[k]);
        return polygons[k]["name"];
      }
    } 
  }
}

function doHitDetection(e){
  drawPoly();
  var xpos = e.clientX-canv.offsetLeft;
  var ypos = e.clientY-canv.offsetTop;
  var txt = "miss";
  if (insidePoly(xpos,ypos)) {
    txt = insideWhichPoly(xpos,ypos);
  }
  document.getElementById("result").innerHTML = "polygon " + txt + ", x: " + xpos + " y: " + ypos;
};

canv.addEventListener("touchend", function(e){doHitDetection(e)}, false);
canv.addEventListener("click", function(e){doHitDetection(e)}, false);

function drawSinglePoly(polygon){
  ctx.beginPath(); 
  ctx.moveTo(polygon[0][0],polygon[0][1]);
  polygon.forEach(function(vertex){
    ctx.lineTo(vertex[0],vertex[1]);
  });
  ctx.lineTo(polygon[0][0],polygon[0][1]);
  ctx.strokeStyle="#FF0000";
  ctx.stroke();
};

function drawPoly(){
  //reset the canvas
  canv.width=canv.width;

  //draw lines for reference
  ctx.beginPath();
  ctx.moveTo(0,90);
  ctx.lineTo(400,90);
  ctx.moveTo(400,120);
  ctx.lineTo(0,120);
  ctx.moveTo(400,140);
  ctx.lineTo(0,140);
  ctx.moveTo(0,150);
  ctx.lineTo(400,150);
  ctx.moveTo(400,160);
  ctx.lineTo(0,160);
  ctx.strokeStyle="#c0c0c0";
  ctx.stroke();

  //draw polygons
  polygons.forEach(function(polygon){
    ctx.beginPath(); 
    ctx.moveTo(polygon[0][0],polygon[0][1]);
    polygon.forEach(function(vertex){
      ctx.lineTo(vertex[0],vertex[1]);
    });
    ctx.lineTo(polygon[0][0],polygon[0][1]);
    ctx.strokeStyle="#000000";
    ctx.stroke();
  });
};

document.onload = drawPoly();
</script>
</body>
</html>
